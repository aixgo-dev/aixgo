# Vector Store Package

The `vectorstore` package provides a unified interface for working with vector
databases in Aixgo. It enables semantic search, similarity matching, and
retrieval-augmented generation (RAG) workflows through a provider-agnostic API.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Supported Providers](#supported-providers)
- [API Reference](#api-reference)
- [Configuration](#configuration)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)
- [Examples](#examples)

## Overview

Vector databases store high-dimensional embeddings alongside metadata,
enabling fast similarity search. This package abstracts common operations
across different vector database providers, allowing you to switch backends
without changing your application code.

### Key Concepts

- **Document**: A piece of content with its embedding vector and metadata
- **Embedding**: A numerical representation (vector) of content, typically generated by a machine learning model
- **Similarity Search**: Finding documents most similar to a query vector
- **Metadata Filtering**: Combining vector search with traditional filters for hybrid search

## Features

- **Provider Agnostic**: Switch between Firestore, memory, and future providers (Qdrant, pgvector) using the same API
- **Flexible Filtering**: Combine vector similarity with metadata filters
- **Batch Operations**: Efficiently upsert and retrieve multiple documents
- **Multiple Distance Metrics**: Cosine similarity, Euclidean distance, dot product
- **Production Ready**: Built-in validation, error handling, and concurrency safety
- **Extensible**: Easy to add custom vector store providers via registry pattern

## Installation

```bash
go get github.com/aixgo-dev/aixgo/pkg/vectorstore
```

### Provider-Specific Dependencies

```bash
# For Firestore support
go get cloud.google.com/go/firestore

# For future Qdrant support
# go get github.com/qdrant/go-client

# For future pgvector support
# go get github.com/pgvector/pgvector-go
```

## Quick Start

### Basic Usage

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/aixgo-dev/aixgo/pkg/vectorstore"
)

func main() {
    // Create an in-memory vector store (for development)
    config := vectorstore.Config{
        Provider:            "memory",
        EmbeddingDimensions: 384,
        DefaultTopK:         10,
        Memory: &vectorstore.MemoryConfig{
            MaxDocuments: 10000,
        },
    }

    store, err := vectorstore.New(config)
    if err != nil {
        log.Fatal(err)
    }
    defer store.Close()

    ctx := context.Background()

    // Create a document with embedding
    doc := vectorstore.Document{
        ID:      "doc-1",
        Content: "Aixgo is a production-grade AI agent framework for Go",
        Embedding: []float32{0.1, 0.2, 0.3, /* ... 384 dimensions total */},
        Metadata: map[string]interface{}{
            "category": "documentation",
            "version":  "1.0",
        },
    }

    // Store the document
    if err := store.Upsert(ctx, []vectorstore.Document{doc}); err != nil {
        log.Fatal(err)
    }

    // Search for similar documents
    results, err := store.Search(ctx, vectorstore.SearchQuery{
        Embedding: []float32{0.11, 0.21, 0.31, /* ... */},
        TopK:      5,
        MinScore:  0.7,
    })
    if err != nil {
        log.Fatal(err)
    }

    for _, result := range results {
        fmt.Printf("Score: %.3f - %s\n", result.Score, result.Document.Content)
    }
}
```

### Production Setup with Firestore

```go
config := vectorstore.Config{
    Provider:            "firestore",
    EmbeddingDimensions: 1536, // OpenAI text-embedding-3-small
    DefaultTopK:         10,
    Firestore: &vectorstore.FirestoreConfig{
        ProjectID:       "my-gcp-project",
        Collection:      "embeddings",
        CredentialsFile: "/path/to/service-account.json", // Optional
    },
}

store, err := vectorstore.New(config)
if err != nil {
    log.Fatal(err)
}
defer store.Close()
```

## Supported Providers

| Provider | Status | Best For | Persistence | Scalability |
|----------|--------|----------|-------------|-------------|
| **memory** | âœ… Available | Development, testing | No | Low (10K docs) |
| **firestore** | âœ… Available | Production, serverless | Yes | High |
| **qdrant** | ðŸš§ Planned | High-performance search | Yes | Very High |
| **pgvector** | ðŸš§ Planned | Existing PostgreSQL apps | Yes | High |

### Memory Provider

**Pros:**

- Zero setup required
- Fast for small datasets
- Perfect for testing

**Cons:**

- Data lost on restart
- Limited capacity (default 10K documents)
- Brute-force search (O(n) complexity)

**Use Cases:**

- Unit tests
- Local development
- Prototyping

### Firestore Provider

**Pros:**

- Serverless, fully managed
- Automatic scaling
- Real-time sync capabilities
- Built-in security rules

**Cons:**

- Requires GCP setup
- Costs based on operations
- Index creation takes time

**Use Cases:**

- Production deployments
- Serverless architectures
- Projects already using Firebase/GCP

## API Reference

### VectorStore Interface

```go
type VectorStore interface {
    // Upsert inserts or updates documents with embeddings
    Upsert(ctx context.Context, documents []Document) error

    // Search performs similarity search
    Search(ctx context.Context, query SearchQuery) ([]SearchResult, error)

    // Delete removes documents by IDs
    Delete(ctx context.Context, ids []string) error

    // Get retrieves documents by IDs
    Get(ctx context.Context, ids []string) ([]Document, error)

    // Close closes the connection
    Close() error
}
```

### Document Structure

```go
type Document struct {
    ID        string                 // Unique identifier
    Content   string                 // Text content
    Embedding []float32              // Vector representation
    Metadata  map[string]interface{} // Additional information
    CreatedAt time.Time              // Creation timestamp
    UpdatedAt time.Time              // Last update timestamp
}
```

### Search Query

```go
type SearchQuery struct {
    Embedding      []float32        // Query vector
    TopK           int              // Number of results (default: 10, max: 1000)
    MinScore       float32          // Minimum similarity (0.0-1.0)
    Filter         *MetadataFilter  // Optional metadata filtering
    DistanceMetric string           // "cosine", "euclidean", "dot_product"
}
```

### Metadata Filtering

```go
type MetadataFilter struct {
    Must    map[string]interface{} // All conditions must match (AND)
    Should  map[string]interface{} // At least one must match (OR)
    MustNot map[string]interface{} // None must match (NOT)
}
```

Example:

```go
filter := &vectorstore.MetadataFilter{
    Must: map[string]interface{}{
        "category": "documentation",
        "status":   "published",
    },
    MustNot: map[string]interface{}{
        "archived": true,
    },
}
```

### Distance Metrics

```go
const (
    DistanceMetricCosine     = "cosine"      // Default, range: -1 to 1
    DistanceMetricEuclidean  = "euclidean"   // Range: 0 to infinity
    DistanceMetricDotProduct = "dot_product" // Range: -inf to +inf
)
```

**When to use:**

- **Cosine**: Most text embeddings (normalized vectors)
- **Euclidean**: When vector magnitude matters
- **Dot Product**: Faster than cosine for normalized vectors

## Configuration

### Memory Configuration

```go
config := vectorstore.Config{
    Provider:            "memory",
    EmbeddingDimensions: 384,
    DefaultTopK:         10,
    DefaultDistanceMetric: "cosine",
    Memory: &vectorstore.MemoryConfig{
        MaxDocuments: 10000, // Default: 10000
    },
}
```

### Firestore Configuration

```go
config := vectorstore.Config{
    Provider:            "firestore",
    EmbeddingDimensions: 1536,
    DefaultTopK:         10,
    DefaultDistanceMetric: "cosine",
    Firestore: &vectorstore.FirestoreConfig{
        ProjectID:       "my-project",      // Required
        Collection:      "embeddings",      // Required
        CredentialsFile: "/path/to/key.json", // Optional
        DatabaseID:      "(default)",       // Optional
    },
}
```

### Environment Variables

```bash
# For Firestore with Application Default Credentials
export GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json

# Alternatively, use gcloud auth
gcloud auth application-default login
```

## Best Practices

### 1. Document Design

**Keep content focused:**

```go
// Good: Focused, semantic chunk
doc := vectorstore.Document{
    ID:      "user-guide-installation",
    Content: "To install Aixgo, run: go get github.com/aixgo-dev/aixgo",
    Metadata: map[string]interface{}{
        "source":   "user-guide",
        "section":  "installation",
        "language": "en",
    },
}

// Avoid: Too large, mixed topics
doc := vectorstore.Document{
    Content: "... entire 50-page user manual ...",
}
```

### 2. Metadata Strategy

**Use hierarchical metadata:**

```go
Metadata: map[string]interface{}{
    "doc_type":  "guide",
    "category":  "getting-started",
    "version":   "2.0",
    "author":    "docs-team",
    "created":   "2025-01-15",
    "tags":      []string{"installation", "quickstart"},
    "language":  "en",
    "priority":  1,
}
```

### 3. Batch Operations

**Prefer batch upserts:**

```go
// Good: Batch operation
documents := make([]vectorstore.Document, 100)
// ... populate documents ...
if err := store.Upsert(ctx, documents); err != nil {
    return err
}

// Avoid: Individual operations
for _, doc := range documents {
    if err := store.Upsert(ctx, []vectorstore.Document{doc}); err != nil {
        return err
    }
}
```

### 4. Error Handling

**Validate before operations:**

```go
// Validate document
if err := vectorstore.ValidateDocument(&doc); err != nil {
    return fmt.Errorf("invalid document: %w", err)
}

// Validate search query
if err := vectorstore.ValidateSearchQuery(&query); err != nil {
    return fmt.Errorf("invalid query: %w", err)
}

// Perform operation
if err := store.Upsert(ctx, []vectorstore.Document{doc}); err != nil {
    return fmt.Errorf("upsert failed: %w", err)
}
```

### 5. Context and Timeouts

**Always use timeouts:**

```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

results, err := store.Search(ctx, query)
if err != nil {
    if errors.Is(err, context.DeadlineExceeded) {
        return fmt.Errorf("search timeout: %w", err)
    }
    return err
}
```

### 6. Resource Cleanup

**Always close connections:**

```go
store, err := vectorstore.New(config)
if err != nil {
    return err
}
defer store.Close() // Important!
```

## Troubleshooting

### Embedding Dimension Mismatch

```text
Error: embedding dimension mismatch: expected 384, got 1536
```

**Solution:** Ensure `EmbeddingDimensions` matches your embedding model:

```go
// OpenAI text-embedding-3-small: 1536 dimensions
config.EmbeddingDimensions = 1536

// HuggingFace all-MiniLM-L6-v2: 384 dimensions
config.EmbeddingDimensions = 384
```

### Firestore Permission Denied

```text
Error: rpc error: code = PermissionDenied
```

**Solution:** Grant proper IAM roles:

```bash
gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:SERVICE_ACCOUNT@PROJECT.iam.gserviceaccount.com" \
  --role="roles/datastore.user"
```

### Firestore Index Not Ready

```text
Error: index not found or not ready
```

**Solution:** Wait for index creation (5-10 minutes):

```bash
# Check index status
gcloud firestore indexes composite list --format=table

# Create index
gcloud firestore indexes composite create \
  --collection-group=embeddings \
  --query-scope=COLLECTION \
  --field-config=field-path=embedding,vector-config='{"dimension":"384","flat":{}}'
```

### Search Returns No Results

**Check these common issues:**

1. **MinScore too high:** Try lowering or removing it
2. **Wrong distance metric:** Use cosine for most text embeddings
3. **Filters too restrictive:** Test without filters first
4. **Empty database:** Verify documents were stored

```go
// Debug: Search without filters
results, err := store.Search(ctx, vectorstore.SearchQuery{
    Embedding: queryVec,
    TopK:      100,
    MinScore:  0.0, // Remove score threshold
    // Filter: nil, // Remove filters
})
```

### Memory Limit Exceeded

```text
Error: would exceed max documents limit: 10000
```

**Solution:** Increase limit or switch to persistent storage:

```go
config.Memory.MaxDocuments = 50000 // Increase limit

// Or use Firestore for unlimited storage
config.Provider = "firestore"
```

## Examples

### Example 1: Hybrid Search with Metadata Filters

```go
// Search for recent documentation in English
results, err := store.Search(ctx, vectorstore.SearchQuery{
    Embedding: queryEmbedding,
    TopK:      10,
    MinScore:  0.75,
    Filter: &vectorstore.MetadataFilter{
        Must: map[string]interface{}{
            "doc_type": "documentation",
            "language": "en",
            "status":   "published",
        },
        MustNot: map[string]interface{}{
            "archived": true,
        },
    },
})
```

### Example 2: Bulk Document Management

```go
// Upsert multiple documents
documents := []vectorstore.Document{
    {ID: "doc-1", Content: "...", Embedding: emb1, Metadata: meta1},
    {ID: "doc-2", Content: "...", Embedding: emb2, Metadata: meta2},
    {ID: "doc-3", Content: "...", Embedding: emb3, Metadata: meta3},
}
if err := store.Upsert(ctx, documents); err != nil {
    log.Fatal(err)
}

// Retrieve specific documents
docs, err := store.Get(ctx, []string{"doc-1", "doc-2"})
if err != nil {
    log.Fatal(err)
}

// Delete documents
if err := store.Delete(ctx, []string{"doc-3"}); err != nil {
    log.Fatal(err)
}
```

### Example 3: Custom Provider Registration

```go
package main

import "github.com/aixgo-dev/aixgo/pkg/vectorstore"

func init() {
    // Register custom provider
    vectorstore.Register("custom", func(config vectorstore.Config) (vectorstore.VectorStore, error) {
        return NewCustomVectorStore(config)
    })
}

type CustomVectorStore struct {
    // Your implementation
}

func (c *CustomVectorStore) Upsert(ctx context.Context, documents []vectorstore.Document) error {
    // Implementation
}

// Implement remaining interface methods...
```

### Example 4: Multi-Tenancy

```go
// Use metadata for tenant isolation
func upsertTenantDocument(store vectorstore.VectorStore, tenantID string, doc vectorstore.Document) error {
    doc.Metadata["tenant_id"] = tenantID
    return store.Upsert(ctx, []vectorstore.Document{doc})
}

func searchTenantDocuments(store vectorstore.VectorStore, tenantID string, query vectorstore.SearchQuery) ([]vectorstore.SearchResult, error) {
    query.Filter = &vectorstore.MetadataFilter{
        Must: map[string]interface{}{
            "tenant_id": tenantID,
        },
    }
    return store.Search(ctx, query)
}
```

## Performance Considerations

### Memory Provider

- **Complexity**: O(n) for search (brute-force)
- **Throughput**: ~10,000 searches/sec (depends on dimensions)
- **Capacity**: Up to 100K documents on typical hardware

### Firestore Provider

- **Complexity**: O(log n) with vector index
- **Throughput**: ~1,000 searches/sec (network bound)
- **Capacity**: Unlimited (serverless)

### Optimization Tips

1. **Use batch operations** for bulk inserts
2. **Set appropriate TopK** (smaller = faster)
3. **Add metadata filters** to reduce search space
4. **Consider embedding dimensions** (smaller = faster, less accurate)
5. **Use connection pooling** (automatic with Firestore)

## Next Steps

- **RAG Implementation**: See [examples/rag-agent](../../examples/rag-agent)
- **Custom Providers**: See [guides/extending-aixgo.md](../../web/content/guides/extending-aixgo.md)
- **Production Deployment**: See [guides/production-deployment.md](../../web/content/guides/production-deployment.md)
- **Embeddings**: See [pkg/embeddings/README.md](../embeddings/README.md)

## Resources

- [Firestore Vector Search Documentation](https://firebase.google.com/docs/firestore/vector-search)
- [Understanding Vector Databases](https://www.pinecone.io/learn/vector-database/)
- [Embedding Best Practices](https://platform.openai.com/docs/guides/embeddings/use-cases)

## Contributing

To add a new vector store provider:

1. Implement the `VectorStore` interface
2. Register your provider in `init()`
3. Add configuration structs to `config.go`
4. Add tests and documentation
5. Submit a pull request

See [CONTRIBUTING.md](../../CONTRIBUTING.md) for details.
