# Vector Store Package

The `vectorstore` package provides a unified interface for working with vector
databases in Aixgo. It enables semantic search, similarity matching, and
retrieval-augmented generation (RAG) workflows through a provider-agnostic API.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Supported Providers](#supported-providers)
- [API Reference](#api-reference)
- [Best Practices](#best-practices)
- [Troubleshooting](#troubleshooting)
- [Examples](#examples)

## Overview

Vector databases store high-dimensional embeddings alongside metadata,
enabling fast similarity search. This package abstracts common operations
across different vector database providers, allowing you to switch backends
without changing your application code.

### Key Concepts

- **Collection**: Isolated namespace with use-case specific configuration
- **Document**: A piece of content with its embedding vector and metadata
- **Embedding**: A numerical representation (vector) of content, typically generated by a machine learning model
- **Query**: Type-safe search with composable filters
- **Multi-modal Content**: Support for text, images, audio, and video

## Features

- **Collection-Based Isolation**: Separate namespaces for different use cases
- **Provider Agnostic**: Switch between memory, Firestore, and future providers using the same API
- **Multi-Modal Support**: Text, images, audio, and video content
- **Flexible Filtering**: Compose type-safe filters with And/Or/Not
- **Batch Operations**: Efficiently upsert and retrieve multiple documents
- **Streaming Support**: Handle large result sets with iterators
- **Multiple Distance Metrics**: Cosine similarity, Euclidean distance, dot product
- **Production Ready**: Built-in validation, error handling, and concurrency safety
- **Extensible**: Easy to add custom vector store providers

## Installation

```bash
go get github.com/aixgo-dev/aixgo/pkg/vectorstore
```

### Provider-Specific Dependencies

```bash
# For Firestore support
go get cloud.google.com/go/firestore
go get github.com/aixgo-dev/aixgo/pkg/vectorstore/firestore

# For in-memory support (included in base package)
go get github.com/aixgo-dev/aixgo/pkg/vectorstore/memory
```

## Quick Start

### Basic Usage with Memory Provider

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/aixgo-dev/aixgo/pkg/vectorstore"
    "github.com/aixgo-dev/aixgo/pkg/vectorstore/memory"
)

func main() {
    // Create an in-memory vector store
    store, err := memory.New()
    if err != nil {
        log.Fatal(err)
    }
    defer store.Close()

    // Get a collection
    coll := store.Collection("documents")

    ctx := context.Background()

    // Create a document with embedding
    doc := &vectorstore.Document{
        ID:      "doc-1",
        Content: vectorstore.NewTextContent("Aixgo is a production-grade AI agent framework for Go"),
        Embedding: vectorstore.NewEmbedding(
            []float32{0.1, 0.2, 0.3, /* ... 384 dimensions total */},
            "text-embedding-3-small",
        ),
        Tags: []string{"documentation", "framework"},
    }

    // Store the document
    result, err := coll.Upsert(ctx, doc)
    if err != nil {
        log.Fatal(err)
    }
    fmt.Printf("Inserted: %d documents\n", result.Inserted)

    // Query for similar documents
    query := &vectorstore.Query{
        Embedding: vectorstore.NewEmbedding(
            []float32{0.11, 0.21, 0.31, /* ... */},
            "text-embedding-3-small",
        ),
        Limit:    5,
        MinScore: 0.7,
    }

    results, err := coll.Query(ctx, query)
    if err != nil {
        log.Fatal(err)
    }

    for _, match := range results.Matches {
        fmt.Printf("Score: %.3f - %s\n", match.Score, match.Document.Content.String())
    }
}
```

### Production Setup with Firestore

```go
import (
    "github.com/aixgo-dev/aixgo/pkg/vectorstore/firestore"
)

// Create Firestore vector store
store, err := firestore.New(
    firestore.WithProject("my-gcp-project"),
    firestore.WithDatabase("(default)"),
    firestore.WithCredentials("/path/to/service-account.json"),
)
if err != nil {
    log.Fatal(err)
}
defer store.Close()

// Get collection with TTL for semantic caching
cache := store.Collection("cache",
    vectorstore.WithTTL(5*time.Minute),
    vectorstore.WithDeduplication(true),
)
```

## Supported Providers

| Provider | Status | Best For | Persistence | Scalability |
|----------|--------|----------|-------------|-------------|
| **memory** | Available | Development, testing | No | Low (10K docs) |
| **firestore** | Available | Production, serverless | Yes | High |
| **qdrant** | Planned | High-performance search | Yes | Very High |
| **pgvector** | Planned | Existing PostgreSQL apps | Yes | High |

### Memory Provider

**Pros:**

- Zero setup required
- Fast for small datasets
- Perfect for testing

**Cons:**

- Data lost on restart
- Limited capacity (default 10K documents)
- Brute-force search (O(n) complexity)

**Use Cases:**

- Unit tests
- Local development
- Prototyping

### Firestore Provider

**Pros:**

- Serverless, fully managed
- Automatic scaling
- Real-time sync capabilities
- Built-in security rules

**Cons:**

- Requires GCP setup
- Costs based on operations
- Index creation takes time

**Use Cases:**

- Production deployments
- Serverless architectures
- Projects already using Firebase/GCP

## API Reference

### VectorStore Interface

```go
type VectorStore interface {
    // Collection returns a collection with the given name and options
    Collection(name string, opts ...CollectionOption) Collection

    // ListCollections returns all collection names
    ListCollections(ctx context.Context) ([]string, error)

    // DeleteCollection removes a collection and all its documents
    DeleteCollection(ctx context.Context, name string) error

    // Stats returns store-level statistics
    Stats(ctx context.Context) (*StoreStats, error)

    // Close closes the connection
    Close() error
}
```

### Collection Interface

```go
type Collection interface {
    // Upsert inserts or updates documents
    Upsert(ctx context.Context, docs ...*Document) (*UpsertResult, error)

    // UpsertBatch efficiently upserts multiple documents
    UpsertBatch(ctx context.Context, docs []*Document, opts ...BatchOption) (*UpsertResult, error)

    // Query performs similarity search
    Query(ctx context.Context, query *Query) (*QueryResult, error)

    // QueryStream returns an iterator for large result sets
    QueryStream(ctx context.Context, query *Query) (ResultIterator, error)

    // Get retrieves documents by IDs
    Get(ctx context.Context, ids ...string) ([]*Document, error)

    // Delete removes documents by IDs
    Delete(ctx context.Context, ids ...string) (*DeleteResult, error)

    // DeleteByFilter removes documents matching a filter
    DeleteByFilter(ctx context.Context, filter Filter) (*DeleteResult, error)

    // Count returns the number of documents matching a filter
    Count(ctx context.Context, filter Filter) (int64, error)
}
```

### Document Structure

```go
type Document struct {
    ID        string       // Unique identifier
    Content   *Content     // Multi-modal (text/image/audio/video)
    Embedding *Embedding   // Vector + model metadata
    Scope     *Scope       // Multi-tenant isolation
    Temporal  *Temporal    // Time-based metadata
    Tags      []string     // Indexed labels
    Metadata  map[string]any // Free-form data
}
```

### Query Structure

```go
type Query struct {
    Embedding         *Embedding     // Query vector
    Filters           Filter         // Composable filters
    Limit             int            // Number of results (default: 10)
    Offset            int            // Pagination offset
    MinScore          float32        // Minimum similarity (0.0-1.0)
    Metric            DistanceMetric // Similarity metric
    IncludeEmbeddings bool           // Include vectors in results
    IncludeContent    bool           // Include content in results
    SortBy            []SortBy       // Hybrid ranking
    Explain           bool           // Debug info
}
```

### Composable Filters

```go
// Composite filters
And(filters...)
Or(filters...)
Not(filter)

// Field-based filters
Eq(field, value)
Ne(field, value)
Gt/Gte/Lt/Lte(field, value)
In/NotIn(field, values...)
Contains/StartsWith/EndsWith(field, substring)

// Tag filters
TagFilter(tag)
TagsFilter(tags...)  // All tags
AnyTagFilter(tags...) // Any tag

// Scope filters
ScopeFilter(scope)
TenantFilter(tenant)
UserFilter(user)
SessionFilter(session)

// Time filters
CreatedAfter/Before(time)
UpdatedAfter/Before(time)
NotExpired()

// Score filters
ScoreAbove/Below/AtLeast(threshold)
```

### Distance Metrics

```go
const (
    DistanceMetricCosine     = "cosine"      // Default, range: -1 to 1
    DistanceMetricEuclidean  = "euclidean"   // Range: 0 to infinity
    DistanceMetricDotProduct = "dot_product" // Range: -inf to +inf
)
```

**When to use:**

- **Cosine**: Most text embeddings (normalized vectors)
- **Euclidean**: When vector magnitude matters
- **Dot Product**: Faster than cosine for normalized vectors

## Best Practices

### 1. Collection Design

**Use collections for isolation:**

```go
// Semantic cache
cache := store.Collection("cache",
    vectorstore.WithTTL(5*time.Minute),
    vectorstore.WithDeduplication(true),
)

// Agent memory
memory := store.Collection("agent-memory",
    vectorstore.WithScope("user", "session"),
)

// Document store
docs := store.Collection("documents",
    vectorstore.WithIndexing(vectorstore.IndexTypeHNSW),
    vectorstore.WithDimensions(768),
)
```

### 2. Document Design

**Keep content focused:**

```go
// Good: Focused, semantic chunk
doc := &vectorstore.Document{
    ID:      "user-guide-installation",
    Content: vectorstore.NewTextContent("To install Aixgo, run: go get github.com/aixgo-dev/aixgo"),
    Embedding: vectorstore.NewEmbedding(embedding, "text-embedding-3-small"),
    Tags:    []string{"installation", "quickstart"},
}

// Avoid: Too large, mixed topics
doc := &vectorstore.Document{
    Content: vectorstore.NewTextContent("... entire 50-page user manual ..."),
}
```

### 3. Batch Operations

**Prefer batch upserts:**

```go
// Good: Batch operation
result, err := coll.UpsertBatch(ctx, documents,
    vectorstore.WithBatchSize(100),
    vectorstore.WithParallelism(4),
)

// Avoid: Individual operations
for _, doc := range documents {
    coll.Upsert(ctx, doc) // Inefficient
}
```

### 4. Error Handling

**Validate before operations:**

```go
// Documents are validated automatically
result, err := coll.Upsert(ctx, doc)
if err != nil {
    return fmt.Errorf("upsert failed: %w", err)
}
```

### 5. Context and Timeouts

**Always use timeouts:**

```go
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

results, err := coll.Query(ctx, query)
if err != nil {
    if errors.Is(err, context.DeadlineExceeded) {
        return fmt.Errorf("query timeout: %w", err)
    }
    return err
}
```

### 6. Resource Cleanup

**Always close connections:**

```go
store, err := memory.New()
if err != nil {
    return err
}
defer store.Close() // Important!
```

## Troubleshooting

### Firestore Permission Denied

```text
Error: rpc error: code = PermissionDenied
```

**Solution:** Grant proper IAM roles:

```bash
gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:SERVICE_ACCOUNT@PROJECT.iam.gserviceaccount.com" \
  --role="roles/datastore.user"
```

### Firestore Index Not Ready

```text
Error: index not found or not ready
```

**Solution:** Wait for index creation (5-10 minutes):

```bash
# Check index status
gcloud firestore indexes composite list --format=table

# Create index
gcloud firestore indexes composite create \
  --collection-group=embeddings \
  --query-scope=COLLECTION \
  --field-config=field-path=embedding,vector-config='{"dimension":"384","flat":{}}'
```

### Query Returns No Results

**Check these common issues:**

1. **MinScore too high:** Try lowering or removing it
2. **Wrong distance metric:** Use cosine for most text embeddings
3. **Filters too restrictive:** Test without filters first
4. **Empty database:** Verify documents were stored

```go
// Debug: Query without filters
results, err := coll.Query(ctx, &vectorstore.Query{
    Embedding: queryVec,
    Limit:     100,
    MinScore:  0.0, // Remove score threshold
})
```

## Examples

### Example 1: Semantic Caching

```go
cache := store.Collection("cache",
    vectorstore.WithTTL(5*time.Minute),
    vectorstore.WithDeduplication(true),
)

// Store
doc := &vectorstore.Document{
    ID:        queryHash,
    Content:   vectorstore.NewTextContent(query),
    Embedding: vectorstore.NewEmbedding(queryEmbedding, "model"),
    Temporal:  vectorstore.NewTemporalWithTTL(5*time.Minute),
    Metadata:  map[string]any{"result": cachedResult},
}
cache.Upsert(ctx, doc)

// Lookup
query := &vectorstore.Query{
    Embedding: vectorstore.NewEmbedding(queryEmbedding, "model"),
    MinScore:  0.95, // High threshold
    Limit:     1,
}
results, _ := cache.Query(ctx, query)
if results.HasMatches() {
    // Cache hit
    result := results.TopMatch().Document.Metadata["result"]
}
```

### Example 2: Hybrid Search with Filters

```go
// Search for recent documentation in English
results, err := coll.Query(ctx, &vectorstore.Query{
    Embedding: queryEmbedding,
    Filters: vectorstore.And(
        vectorstore.Eq("doc_type", "documentation"),
        vectorstore.Eq("language", "en"),
        vectorstore.Eq("status", "published"),
        vectorstore.Not(vectorstore.Eq("archived", true)),
    ),
    Limit:    10,
    MinScore: 0.75,
})
```

### Example 3: Streaming Large Results

```go
iter, err := coll.QueryStream(ctx, &vectorstore.Query{
    Embedding: queryEmbedding,
    Limit:     10000,
})
defer iter.Close()

for iter.Next() {
    match := iter.Match()
    fmt.Printf("Score: %.4f, Doc: %s\n", match.Score, match.Document.ID)
}

if err := iter.Err(); err != nil {
    log.Fatal(err)
}
```

### Example 4: Multi-Modal Search

```go
media := store.Collection("media",
    vectorstore.WithDimensions(512), // CLIP dimensions
)

// Store image
doc := &vectorstore.Document{
    ID:        imageID,
    Content:   vectorstore.NewImageURL(imageURL),
    Embedding: vectorstore.NewEmbedding(clipEmbedding, "clip-vit-base-patch32"),
    Tags:      []string{"photo", "product"},
}
media.Upsert(ctx, doc)

// Query with image embedding
results, _ := media.Query(ctx, &vectorstore.Query{
    Embedding: queryImageEmbedding,
    Filters:   vectorstore.TagFilter("product"),
})
```

## Performance Considerations

### Memory Provider

- **Complexity**: O(n) for search (brute-force)
- **Throughput**: ~10,000 searches/sec (depends on dimensions)
- **Capacity**: Up to 100K documents on typical hardware

### Firestore Provider

- **Complexity**: O(log n) with vector index
- **Throughput**: ~1,000 searches/sec (network bound)
- **Capacity**: Unlimited (serverless)

### Optimization Tips

1. **Use batch operations** for bulk inserts
2. **Set appropriate Limit** (smaller = faster)
3. **Add filters** to reduce search space
4. **Consider embedding dimensions** (smaller = faster, less accurate)
5. **Use streaming** for large result sets
6. **Disable content/embeddings** in results if not needed

## Next Steps

- **RAG Implementation**: See [examples/rag-agent](../../examples/rag-agent)
- **Embeddings**: See [pkg/embeddings/README.md](../embeddings/README.md)
- **Architecture**: See [ARCHITECTURE.md](ARCHITECTURE.md) for design details
- **Quick Reference**: See [QUICK_REFERENCE.md](QUICK_REFERENCE.md) for API cheat sheet

## Resources

- [Firestore Vector Search Documentation](https://firebase.google.com/docs/firestore/vector-search)
- [Understanding Vector Databases](https://www.pinecone.io/learn/vector-database/)
- [Embedding Best Practices](https://platform.openai.com/docs/guides/embeddings/use-cases)

## Contributing

To add a new vector store provider:

1. Implement the `VectorStore` and `Collection` interfaces
2. Add provider-specific constructors (e.g., `yourprovider.New()`)
3. Add tests and documentation
4. Submit a pull request

See [CONTRIBUTING.md](../../CONTRIBUTING.md) for details.
